[-] Type system
    [ ] forall qualifier
    [ ] Typeclasses/traits
    [ ] Maybe
    [ ] 'a File
    [ ] "See through" types that act as an instance of their parameter
        [ ] () -> 'a
        [ ] 'a File

[-] Language
    [-] Expressions
        [-] Literals
            [x] Integer
            [ ] Number
            [ ] Lambda
            [x] Str
            [-] File
            [-] Glob
                [x] *
                [-] []
                [ ] {}
            [x] Tuple
            [-] List
            [ ] (String) format?
            [ ] Directory (trailing /)
            [ ] Regex
            [ ] Option (as in flags)
            [ ] Operators bracketed as functions
        [ ] Files
            [ ] /
            [ ] |>
            [ ] |+> (different spelling? `append`?)
        [-] Function
            [-] Application
            [-] Pipe op
                - Right associative composition
            [x] Explicit fn
            [ ] Named (optional?) arguments
            [-] Implicit conversions
                [ ] Path -> File
                fmap over:
                [x] Lists, ['a]
                [ ] Maybe, 'a?
                [ ] Generalize to all?
            [ ] Options
        [ ] Arithmetic
        [ ] String
            [ ] Concat
            [ ] Formatting
        [-] Iterables
            [x] List concat
        [ ] Comparison
        [ ] Boolean
        [ ] Branching
    [ ] Statements
        [ ] Decl/assignment
        [ ] Functions
            [ ] Options
            [ ] Dependency functions
        [ ] if, while, for, switch
        [ ] Working directory control
            into <dir>: {}
    [ ] Error handling
    [ ] Macros
    [ ] Modules

[-] Library
    [x] size :: File -> Integer
        - Size
        - Exceptions? Return Maybe?
    [x] sum :: [Integer] -> Integer
        - Adapt for Number
    [x] zipf :: (File -> Integer) -> File -> (Integer, File)
        - Make polymorphic

[-] Interfacing with legacy Unix

[ ] C API

[ ] Concurrent IO

[ ] Diagnostics
    [ ] Position information
    [ ] Colour
    [ ] Underlining
    [ ] Specific parsing issues
        [ ] Fn-app: refer to specific args

[-] UI
    [-] Prompt
    [ ] Completion
    [ ] Syntax highlighting
    [-] Output highlighting
    [-] Value printing
    [ ] Job control

---------

[-] Gather todos
[ ] Minimize asserts
[ ] Multithreaded Boehm leaks (currently suppressed)
[ ] Pull bool fns from loops
[ ] "Optimizations the compiler can't make"
[ ] hsearch and tsearch for hashmap
[ ] Document the purpose of each module

== Structures

[ ] No {ast,sym}::children by default, allocate on need
[ ] Value printing must depend on the type

type:
[ ] Each type T contains a hashmap of fn types T -> K where K is the key. Use this to only allocate one of each fn type.
[ ] And for lists. Then generalize for any parametric type.
[ ] Create type str in the ctor?
[-] Type equality

ast:
[ ] Make AST::children a const_vector (combined length and size fields)
[ ] Pooled allocator for AST
[ ] Unpackers for the AST (and others?)
[x] opKind -> str
[ ] Add a field to the AST, a reference to relevant token

sym:
[ ] Change sym::children to a hashmap

value:
[x] valueInvalid

== Passes

Lexer:
[ ] Unicode
[ ] Make the lexer create a vector of tokens which persist, own their buffers
[ ] Put location info in tokens
[ ] Lexer op classes

Analyzer:
[x] Each analyzer routine returns type, handler assigns

Runner:
[ ] Optimization for calling n-ary valueFns (creating curried values)
