[-] Type system
    [x] forall qualifier
    [-] Unification instead of typeIsEqual
        [ ] Operators that expect matching operands e.g. ++
    [ ] Typeclasses/traits
    [ ] Maybe
    [ ] 'a File
    [ ] "See through" types that act as an instance of their parameter
        [ ] () -> 'a
        [ ] 'a File

[-] Language
    [-] Values
        [x] Integer
        [x] Number
        [x] Str
        [ ] Lambda
        [ ] Bracketed operators
        [ ] (String) format
        [ ] Regex
        [ ] Option (as in flags)
        -----
        [x] Tuple
        [x] List
        [ ] Records
        [ ] Dictionary
        -----
        [-] File
            [ ] Fix paths
                - Root spelled '-'
                - Home directories, '~'
        [ ] Directory (trailing /)
        [ ] FileListing (like ls -l)
        [-] Glob
            [x] *
            [ ] **
            [-] []
            [ ] {}
        [ ] URL
    [ ] Access to:
        [ ] Environment variables
        [ ] History
    [-] Expressions
        [ ] Files
            [ ] /
            [ ] |>
            [ ] |+> (different spelling? `append`?)
        [-] Function
            [-] Application
            [-] Pipe op
                - Right associative composition
                [ ] filter |?
                [ ] reduce
                [ ] zipf |:
            [x] Explicit fn
            [ ] Named (optional?) arguments
            [-] Implicit conversions
                - fmap over:
                [x] Lists, ['a]
                [ ] Maybe, 'a?
                [ ] Generalize to all?
            [ ] Options
        [ ] Arithmetic
        [ ] String
            [ ] Concat
            [ ] Formatting
        [-] Iterables
            [x] List concat
            [ ] Slices
        [ ] Comparison
        [ ] Boolean
        [ ] Branching
    [ ] Statements
        [-] Decl/assignment
        [ ] Functions
            [ ] Options
            [ ] Dependency functions
        [ ] if, while, for, switch
        [ ] Working directory control
            into <dir>: {}
            mkdir <dir>: {}
        [ ] Transactions (on the fs)
    [ ] Error handling
    [ ] Macros
    [ ] Modules

[-] Library
    [x] size :: File -> Int
        - Size
        - Exceptions? Return Maybe?
    [x] sum :: [Int] -> Int
        - Adapt for Number
    [x] zipf :: (File -> Int) -> File -> (Int, File)
        - Make polymorphic

[-] Interfacing with legacy Unix

[ ] C API

[ ] Unicode
    [ ] In the lexer
    [ ] Other places e.g. strlen -> strwidth

[ ] Diagnostics
    [ ] Position information
    [ ] Colour
    [ ] Underlining
    [ ] Specific parsing issues
        [ ] Fn-app: refer to specific args

[-] UI
    [ ] Interactivity
        [ ] Completion
        [ ] Syntax highlighting
        [ ] Interactive command construction, extensible
        [ ] Job control
        [ ] History available as an iterable
    [ ] Display
        [-] Value printing
            [-] Highlighting
            [ ] Escape strings
            [ ] Long string truncation
    [-] Prompt
    [ ] Progress indicator

[ ] Backend
    [ ] JIT
    [ ] Compilation to POSIX shell

---------

[-] Gather todos
[ ] Minimize asserts !!!!
[ ] Multithreaded Boehm leaks (currently suppressed)
[ ] Pull bool fns from loops
[ ] Document the purpose of each module

== Containers

[ ] Add a fixed size array type

vector:
[ ] auto stored buffer hybrid?

hashmap:
[ ] Simplify impl.
[ ] tsearch and tsearch?
[ ] Args of const map* -> map
[ ] Change XXXAdd to XXXSet and make an XXXAdd that doesn't overwrite values

== Language structures


[ ] No {ast,sym}::children by default, allocate on need
[ ] Value printing must depend on the type

type:
[ ] Each type T contains a hashmap of fn types T -> K where K is the key. Use this to only allocate one of each fn type.
[ ] And for lists. Then generalize for any parametric type.
[ ] Create type str in the ctor?
[-] Type equality
[ ] Higher-kinded type printing

ast:
[ ] Make AST::children a const_vector (combined length and size fields)
[ ] Pooled allocator for AST
[ ] Unpackers for the AST (and others?)
[x] opKind -> str
[ ] Add a field to the AST, a reference to relevant token

sym:
[ ] Change sym::children to a hashmap

value:
[x] valueInvalid

== Passes

Lexer:
[ ] Make the lexer create a vector of tokens which persist, own their buffers
[ ] Put location info in tokens
[ ] Lexer op classes
[ ] Keyword / op trie

Analyzer:
[x] Each analyzer routine returns type, handler assigns
[ ] ListLit: check element equality

Runner:
[ ] Optimization for calling n-ary valueFns (creating curried values)
